/*==============================================
	■■■ 클래스 고급■■■					★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
-상속 관계에 있는 클래스들 간의 캐스팅												!중요!
-업 캐스팅, 다운 캐스팅							★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
================================================*/
/*

*/
// Super class_부모클래스,상위클래스
class SuperTest112
{
	public int a =10,b = 20;

	public void write()
	{
		System.out.println(" 슈퍼클래스...write()메소드");
	}

	public int hap()
	{
		return a + b;
	}
}
//sub class_자식클래스,하위클래스
class SubTest112 extends SuperTest112
{
		public int b =100, c=200;
		
		@Override
		public int hap()
		{
			return a + b + c;
		}
	public void print()
	{
		System.out.println(" 서브클래스...print()메소드");
	}

		

}
//main()메소드를 포함하는 외부의 다른 클래스
public class Test112
{
	public static void main(String[] args)
	{
		//sub class기반 인스턴스 생성
		SubTest112 ob1 = new SubTest112();
		System.out.println("ob.b : " + ob1.b);
		//ob.b : 100 출력
		
		//○업 캐스팅
		//SuperTest112 ob2;
		SuperTest112 ob2 = ob1;		// 『SuperTest112 ob2= (SyperTest112)ob1;』과 동일한 코드


		/*
		학생 중호 = new 학생();

		인간 사람 = 중호; // 『인간 사람 = (인간)중호;』과 동일한 코드
	
		byte a = 10;
		sort b -a;		//『short b = (short)a;』과 동일한 코드

		*/


		System.out.println("ob2.b : " + ob2.b);
		//==>>ob2.b : 20
		//==변수는 객체별로 따로 할당되므로
		//변수 b는 ob2의 변수이다.

		System.out.println("합 : " + ob2.hap());	//-->합 : 310 : sub 100 +200 + super 10 (구문 32에 의해!!!)
													//==>hap () 메소드는 오버라이딩 되어 있고
													// ob2 는 ob1을 업캐스팅 한 상태의 객체이므로
													//『SuperTest112』의 hap() 메소드를 호출하는 것이 아니라 『SubTest112』에서 재정의 한 hap()
													//메소드를 호출하게 된것
													// 즉, 메소드는 업캐스팅이 되더라도 재정의 (덮어쓰기) 한 이상 원래 기능 되돌릴수없다


		ob2.write();
		//=> 슈퍼클래스...write()메소드

		//ob2.print();						//다운캐스팅이 필요!
		// cannot find symbol 컴파일 에러==> ★자식은 부모의 것을 알수있지만 부모는 자식의 것을 알수 없다

		// ○다운 캐스팅
		((SubTest112)ob2).print();
		// => 서브클래스...print()메소드 ==> 객체의 형변환 방법

		/*
		byte a =10;

		short b = a;
	
		byte c =(byte) b;
		*/



// ※ 추가 관찰 -------------------------------------------------------------
		//    다운 캐스팅 가능 여부

		SuperTest112 ob3 = new SuperTest112();
		SubTest112 ob4;

		System.out.println(ob3.c);
		//--==>> 에러 발생
		//====>> Super 클래스의 c는 없다~~~~~~~~~~!!  즉) 상위 객체는 하위 객체의 멤버에 접근하는 것이 불가능하다.
		//cannot find symbol  부모는 자식의 값을 모름!!!!!!!!!!!!


		//ob4 = ob3;
		//--==>> 에러 발생 (ob4가 ob3보다 작기 때문에 자동 형 변환 법칙에 위배된다.)
		//--     상위 객체는 하위 객체에 담을 수(참조할 수) 없다.


		//ob4 = (SubTest)ob3;
		//--==>> 에러 발생(런타임 에러)
		//--     작성된 구문의 문법적인 구조만 봤을 때
		//       다운 캐스팅이 이루어지는 상황이다.
		//       하지만 정상적인 캐스팅이 이루어지지 않는다.
		//      현재 SubTest 객체에 대해 메모리 할당이 이루어지지 않은 상태이기 때문에
		//       다운 캐스팅은 불가능한 것이다.





		//System.out.println(ob4.c);
		//--==>> 에러 발생(컴파일 에러)

	}

}

/*
●업케스팅 , 다운캐스팅이 정상적으로 이루어지는 경우=======================================

1. 하위 객체 생성;				//check!
2. 상위 = 하위대입;				// 업캐스팅_ (정상) 생성객층: 하위
3. 하위 = 상위대입;				// 에러 발생
4. 하위 = (하위) 상위;			//다운캐스팅. (정상)

다운캐스팅이 정상적으로 이루어지지 않은 경우=======================================
1. 상위 객체 생성;					//check!
2. 하위 = 상위 대입;				//에러발생
3. 하위 = (하위)상위 대입;			//(강제 형 변환)다운캐스팅이지만 런타임 에러 발생.



==> 업캐스팅은 언제나 항상 가능.

==> 다운캐스팅은 경우에 따라 가능.
*/


